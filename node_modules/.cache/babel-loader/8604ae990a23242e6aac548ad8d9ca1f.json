{"ast":null,"code":"import * as ActionTypes from './ActionTypes';\nexport const DatasetFiles = (state = {\n  isLoading: true,\n  isQuery: false,\n  errMess: null,\n  datasetFiles: []\n}, action) => {\n  switch (action.type) {\n    case ActionTypes.ADD_DATASETFILES:\n      console.log(\"I wanna check dataset file\");\n      return { ...state,\n        isLoading: false,\n        errMess: null,\n        isQuery: false,\n        datasetFiles: action.payload\n      };\n\n    case ActionTypes.QUERY_DATASETFILES:\n      return { ...state,\n        isLoading: false,\n        errMess: null,\n        isQuery: true,\n        datasetFiles: action.payload\n      };\n\n    case ActionTypes.DATASETFILES_LOADING:\n      return { ...state,\n        isLoading: true,\n        errMess: null,\n        datasetFiles: []\n      };\n\n    case ActionTypes.DATASETFILES_FAILED:\n      return { ...state,\n        isLoading: false,\n        errMess: action.payload\n      };\n    // when a user upload a dataset, we will first send the dataset to the server,\n    // if the dataset is successfully added on the server site, and the server sends back a success of the posting of the dataset\n    // only then we will add it to the redux store.\n\n    case ActionTypes.UPLOAD_DATASET:\n      var dataset = action.payload; // get the uploaded dataset\n\n      return { ...state,\n        datasetFiles: state.datasetFiles.concat(dataset)\n      };\n\n    case ActionTypes.REMOVE_DATASET:\n      console.log(\"start delete\");\n      var datasetName = action.payload; // to get the filename of the selected dataset\n\n      let deletedIndex = 0; // to find the corresponding index based on filename\n\n      console.log(\"get dataset is \" + datasetName);\n\n      for (let [index, eachDataset] of Object.entries(state.datasetFiles)) {\n        if (eachDataset.FileName === datasetName) {\n          deletedIndex = parseInt(index, 10);\n        }\n      }\n\n      console.log(\"deletedIndex is \" + deletedIndex);\n      const newDataset = [...state.datasetFiles.slice(0, deletedIndex), ...state.datasetFiles.slice(deletedIndex + 1, state.datasetFiles.length)];\n      return { ...state,\n        datasetFiles: newDataset\n      };\n\n    case ActionTypes.MODIFY_BRIFINFO:\n      console.log(\"start modify briefInfo in a dataset file!\");\n      var briefInfo_datasetName = action.payload; // to get the new briefInfo\n\n      var briefInfo = briefInfo_datasetName[1];\n      var datasetName = briefInfo_datasetName[0];\n      const updatedDataset = state.datasetFiles.map(item => {\n        if (item.FileName === datasetName) {\n          item.BriefInfo = briefInfo;\n          console.log(\"get item: \", item);\n          return item;\n        } else {\n          return item;\n        }\n      });\n      console.log(\"new updatedDatasets: \", updatedDataset);\n      return { ...state,\n        datasetFiles: updatedDataset\n      };\n\n    default:\n      return state;\n  }\n};\n_c = DatasetFiles;\n\nvar _c;\n\n$RefreshReg$(_c, \"DatasetFiles\");","map":{"version":3,"sources":["/Users/liuanzi/Desktop/Capstone/som/src/redux/datasetFiles.js"],"names":["ActionTypes","DatasetFiles","state","isLoading","isQuery","errMess","datasetFiles","action","type","ADD_DATASETFILES","console","log","payload","QUERY_DATASETFILES","DATASETFILES_LOADING","DATASETFILES_FAILED","UPLOAD_DATASET","dataset","concat","REMOVE_DATASET","datasetName","deletedIndex","index","eachDataset","Object","entries","FileName","parseInt","newDataset","slice","length","MODIFY_BRIFINFO","briefInfo_datasetName","briefInfo","updatedDataset","map","item","BriefInfo"],"mappings":"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","sourcesContent":["import * as ActionTypes from './ActionTypes';\r\n\r\nexport const DatasetFiles = (state = {\r\n    isLoading: true,\r\n    isQuery: false,\r\n    errMess: null,\r\n    datasetFiles: []\r\n}, action) => {\r\n    switch (action.type) {\r\n        case ActionTypes.ADD_DATASETFILES:\r\n            console.log(\"I wanna check dataset file\");\r\n            return { ...state, isLoading: false, errMess: null, isQuery: false, datasetFiles: action.payload };\r\n\r\n        case ActionTypes.QUERY_DATASETFILES:\r\n            return { ...state, isLoading: false, errMess: null, isQuery: true, datasetFiles: action.payload };\r\n\r\n        case ActionTypes.DATASETFILES_LOADING:\r\n            return { ...state, isLoading: true, errMess: null, datasetFiles: [] }\r\n\r\n        case ActionTypes.DATASETFILES_FAILED:\r\n            return { ...state, isLoading: false, errMess: action.payload };\r\n\r\n        // when a user upload a dataset, we will first send the dataset to the server,\r\n        // if the dataset is successfully added on the server site, and the server sends back a success of the posting of the dataset\r\n        // only then we will add it to the redux store.\r\n        case ActionTypes.UPLOAD_DATASET:\r\n            var dataset = action.payload; // get the uploaded dataset\r\n            return { ...state, datasetFiles: state.datasetFiles.concat(dataset) };\r\n\r\n        case ActionTypes.REMOVE_DATASET:\r\n            console.log(\"start delete\");\r\n            var datasetName = action.payload; // to get the filename of the selected dataset\r\n            let deletedIndex = 0; // to find the corresponding index based on filename\r\n            console.log(\"get dataset is \" + datasetName);\r\n            for (let [index, eachDataset] of Object.entries(state.datasetFiles)) {\r\n                if (eachDataset.FileName === datasetName) {\r\n                    deletedIndex = parseInt(index, 10);\r\n                }\r\n            }\r\n\r\n            console.log(\"deletedIndex is \" + deletedIndex);\r\n\r\n            const newDataset = [\r\n                ...state.datasetFiles.slice(0, deletedIndex),\r\n                ...state.datasetFiles.slice(deletedIndex + 1, state.datasetFiles.length)];\r\n\r\n            return { ...state, datasetFiles: newDataset };\r\n\r\n        case ActionTypes.MODIFY_BRIFINFO:\r\n            console.log(\"start modify briefInfo in a dataset file!\");\r\n            var briefInfo_datasetName = action.payload; // to get the new briefInfo\r\n            var briefInfo = briefInfo_datasetName[1];\r\n            var datasetName = briefInfo_datasetName[0];\r\n\r\n            const updatedDataset = state.datasetFiles.map(item => {\r\n                if (item.FileName === datasetName) {\r\n                    item.BriefInfo = briefInfo\r\n                    console.log(\"get item: \", item);\r\n                    return item\r\n                } else {\r\n                    return item\r\n                }\r\n            });\r\n\r\n            console.log(\"new updatedDatasets: \", updatedDataset)\r\n            return { ...state, datasetFiles: updatedDataset };\r\n\r\n\r\n        default:\r\n            return state;\r\n    }\r\n};"]},"metadata":{},"sourceType":"module"}